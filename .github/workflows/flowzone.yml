name: Flowzone

on:
  workflow_call:
    secrets:
      FLOWZONE_TOKEN:
        description: "Personal access token (PAT) for the GitHub service account with admin/owner permissions"
        required: true
      GPG_PRIVATE_KEY:
        description: "GPG private key exported with `gpg --armor --export-secret-keys ...` to sign commits"
        required: false
      GPG_PASSPHRASE:
        description: "Passphrase to decrypt GPG private key"
        required: false
      NPM_TOKEN:
        description: "The npm auth token to use for publishing"
        required: false
      GHCR_TOKEN:
        description: "A personal access token to publish to the GitHub Container Registry, will use FLOWZONE_TOKEN if unset"
        required: false
      DOCKERHUB_USER:
        description: "Username to publish to the Docker Hub container registry"
        required: false
      DOCKER_REGISTRY_USER:
        description: "Deprecated, use DOCKERHUB_USER instead"
        required: false
      DOCKERHUB_TOKEN:
        description: "A personal access token to publish to the Docker Hub container registry"
        required: false
      DOCKER_REGISTRY_PASS:
        description: "Deprecated, use DOCKERHUB_TOKEN instead"
        required: false
      BALENA_API_KEY:
        description: "API key for pushing releases to balena applications"
        required: false
      BALENA_API_KEY_PUSH:
        description: "Deprecated, use BALENA_API_KEY instead"
        required: false
      COMPOSE_VARS:
        description: "Optional base64 encoded docker-compose `.env` file for testing Docker images"
        required: false
    inputs:
      working_directory:
        description: "GitHub actions working directory"
        type: string
        required: false
        default: "."
      docker_images:
        description: "Comma-delimited string of Docker images (without tags) to publish (skipped if empty)"
        type: string
        required: false
        default: ghcr.io/${{ github.repository }}
      balena_slugs:
        description: "Comma-delimited string of balenaCloud apps, fleets, or blocks to deploy (skipped if empty)"
        type: string
        required: false
        default: ${{ github.repository }}
      protect_branch:
        description: "Set to false to disable updating branch protection rules after a successful run"
        type: boolean
        required: false
        default: true
      required_approving_review_count:
        description: "Setting this value to zero effectively means merge==deploy without approval(s)"
        type: string
        required: false
        default: "1"

env:
  GHCR_USER: "flowzone" # does not seem to matter what is used here
  GHCR_TOKEN: ${{ secrets.GHCR_TOKEN || secrets.FLOWZONE_TOKEN }}
  NPM_REGISTRY: registry.npmjs.org

jobs:
  ###################################################
  ## event types
  ###################################################

  event_types:
    name: Event types
    runs-on: ubuntu-latest
    # all jobs depend on this one in some way so add global trigger rules here
    if: |
      (github.event_name == 'pull_request' && github.base_ref == github.event.repository.default_branch) ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/'))

    outputs:
      pr_open: ${{ steps.pr_open.outcome == 'success' }}
      pr_sync: ${{ steps.pr_sync.outcome == 'success' }}
      pr_merge: ${{ steps.pr_merge.outcome == 'success' }}
      tagged: ${{ steps.tagged.outcome == 'success' }}
      do_draft: ${{ steps.pr_open.outcome == 'success' || steps.pr_sync.outcome == 'success' }}
      do_final: ${{ steps.pr_merge.outcome == 'success' || steps.tagged.outcome == 'success' }}

    defaults:
      run:
        working-directory: .
        shell: bash

    env:
      JSON: ${{ toJSON(github) }}

    steps:
      - name: Pull Request opened
        if: github.event_name == 'pull_request' && github.event.action == 'opened'
        id: pr_open
        run: |
          echo "${JSON}" || true

      - name: Pull Request synchronize
        if: github.event_name == 'pull_request' && github.event.action == 'synchronize'
        id: pr_sync
        run: |
          echo "${JSON}" || true

      - name: Pull Request merged
        if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
        id: pr_merge
        run: |
          echo "${JSON}" || true

      - name: Tag event
        if: github.event_name == 'push'
        id: tagged
        run: |
          echo "${JSON}" || true

  ###################################################
  ## project types
  ###################################################

  project_types:
    name: Project types
    runs-on: ubuntu-latest
    needs: [event_types]

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    outputs:
      balena_slugs: ${{ steps.balena_slugs_json.outputs.build }}
      docker_images: ${{ steps.docker_images.outputs.build }}

      npm: ${{ steps.npm.outputs.enabled }}
      npm_private: ${{ steps.npm.outputs.private }} # can be null or unset
      docker_compose: ${{ steps.docker_compose.outputs.enabled }}
      balena: ${{ steps.balena.outputs.enabled }}
      repo_type: ${{ steps.repo.outputs.type }} # can be null or unset
      docker_bake: ${{ steps.docker_bake.outputs.enabled }}
      docker_platforms: ${{ steps.docker_bake.outputs.platforms }}
      node_versions: ${{ steps.node_versions.outputs.json }}

      custom_publish: ${{ steps.custom.outputs.publish }}
      custom_finalize: ${{ steps.custom.outputs.finalize }}
      custom_test: ${{ steps.custom.outputs.test }}

    steps:
      - name: Checkout source
        uses: actions/checkout@v3
        with:
          fetch-depth: 1
          token: ${{ secrets.FLOWZONE_TOKEN }}

      - name: Convert balena_slugs to a JSON array
        id: balena_slugs_json
        uses: kanga333/json-array-builder@v0.1.0
        env:
          INPUT: ${{ inputs.balena_slugs }}
        with:
          cmd: bash -c "echo $INPUT | tr -d '[:space:]'"
          separator: ","

      - name: Convert docker_images to a JSON array
        id: docker_images_json
        uses: kanga333/json-array-builder@v0.1.0
        env:
          INPUT: ${{ inputs.docker_images }}
        with:
          cmd: bash -c "echo $INPUT | tr -d '[:space:]'"
          separator: ","

      - name: Convert docker_images to a newline list
        id: docker_images
        run: |
          echo "::set-output name=build::$(echo '${{ steps.docker_images_json.outputs.build }}' | jq -rc '.[]')"

      - name: Check for package.json
        id: npm
        run: |
          if test -f "package.json"
          then
            echo "found package.json"
            echo "::set-output name=enabled::true"
            echo "::set-output name=private::$(jq -r '.private' package.json)"
            echo "NODE_VERSIONS=[]" >> $GITHUB_ENV
          else
            echo ::set-output name=enabled::"false"
          fi

      # check which past and current and future Node.js LTS releases meet the engine requirements
      # if there are no engine requirements then the current LTS will be used

      - name: Setup Node.js 12.x
        if: steps.npm.outputs.enabled == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: 12.x
      - name: Check engine
        if: steps.npm.outputs.enabled == 'true'
        run: |
          if npx -q -y -- check-engine
          then
            echo "NODE_VERSIONS=$(echo "${NODE_VERSIONS}" | jq -c '. + ["12.x"]')" >> $GITHUB_ENV
          fi

      - name: Setup Node.js 14.x
        if: steps.npm.outputs.enabled == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: 14.x
      - name: Check engine
        if: steps.npm.outputs.enabled == 'true'
        run: |
          if npx -q -y -- check-engine
          then
            echo "NODE_VERSIONS=$(echo "${NODE_VERSIONS}" | jq -c '. + ["14.x"]')" >> $GITHUB_ENV
          fi

      - name: Setup Node.js 16.x
        if: steps.npm.outputs.enabled == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: 16.x
      - name: Check engine
        if: steps.npm.outputs.enabled == 'true'
        run: |
          if npx -q -y -- check-engine
          then
            echo "NODE_VERSIONS=$(echo "${NODE_VERSIONS}" | jq -c '. + ["16.x"]')" >> $GITHUB_ENV
          fi

      - name: Setup Node.js 18.x
        if: steps.npm.outputs.enabled == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: 18.x
      - name: Check engine
        if: steps.npm.outputs.enabled == 'true'
        run: |
          if npx -q -y -- check-engine
          then
            echo "NODE_VERSIONS=$(echo "${NODE_VERSIONS}" | jq -c '. + ["18.x"]')" >> $GITHUB_ENV
          fi

      # default to the current LTS version if none were matched
      # by the engine checks above
      - name: Set Node.js versions
        if: steps.npm.outputs.enabled == 'true'
        id: node_versions
        run: |
          echo "::set-output name=json::[\"16.x\"]"
          if [ "${NODE_VERSIONS}" != "[]" ]
          then
            echo "::set-output name=json::${NODE_VERSIONS}"
          fi

      - name: Check for docker-compose.test.yml
        id: docker_compose
        run: |
          if [ -f docker-compose.test.yml ] && [ -f docker-compose.yml ]; then
            echo "found docker-compose.test.yml"
            echo ::set-output name=enabled::"true"
          else
            echo ::set-output name=enabled::"false"
          fi

      - name: Check for balena.yml
        id: balena
        run: |
          if test -f balena.yml
          then
            echo "found balena.yml"
            echo ::set-output name=enabled::"true"
          else
            echo ::set-output name=enabled::"false"
          fi

      - name: Check for custom jobs
        id: custom
        working-directory: .
        run: |
          if [ -d .github/flowzone/publish ]
          then
            echo "::set-output name=publish::true"
          fi
          if [ -d .github/flowzone/finalize ]
          then
            echo "::set-output name=finalize::true"
          fi
          if [ -d .github/flowzone/test ]
          then
            echo "::set-output name=test::true"
          fi

      - name: Check for repo.yml
        id: repo
        working-directory: .
        run: |
          if [ -f repo.yml ]
          then
            echo "::set-output name=type::$(yq e .type repo.yml)"
          fi

      - name: Check for docker-bake.hcl
        id: docker_bake
        run: |
          echo "::set-output name=enabled::false"
          echo "::set-output name=platforms::[\"linux/amd64\"]"
          if [ -f docker-bake.hcl ]
          then
            echo "::set-output name=enabled::true"
            curl -fsSL https://github.com/teamon/hclq/releases/download/v0.1.1/hclq_0.1.1_Linux_x86_64.gz -O
            echo "cc05154fd66e5a0c4185a95712980a5f  hclq_0.1.1_Linux_x86_64.gz" | md5sum -c -
            gzip -d hclq_0.1.1_Linux_x86_64.gz
            chmod +x ./hclq_0.1.1_Linux_x86_64
            platforms_json="$(./hclq_0.1.1_Linux_x86_64 < docker-bake.hcl | jq -rc .target.build.platforms)"
            if [ -n "${platforms_json}" ] && [ "${platforms_json}" != "null" ] && [ "${platforms_json}" != "[]" ]
            then
              echo "::set-output name=platforms::${platforms_json}"
            fi
            rm hclq_0.1.1_Linux_x86_64
          fi

  ###################################################
  ## versioned source
  ###################################################

  versioned_source:
    name: Versioned source
    runs-on: ubuntu-latest
    needs: [event_types, project_types]

    defaults:
      run:
        working-directory: .
        shell: bash --noprofile --norc -eo pipefail -x {0}

    outputs:
      new_tag: ${{ steps.versionist.outputs.new_tag }}
      version: ${{ steps.versionist.outputs.version }}

    steps:
      - name: Checkout source
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.FLOWZONE_TOKEN }}

      - name: Import GPG key for signing commits
        if: needs.project_types.outputs.repo_type != '' && github.event_name == 'pull_request'
        id: import-gpg
        uses: crazy-max/ghaction-import-gpg@v4
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_config_global: true
          git_user_signingkey: true
          git_commit_gpgsign: true

      - name: Generate changelog
        if: needs.project_types.outputs.repo_type != '' && github.event_name == 'pull_request'
        run: |
          if [ ! -f .versionbot/CHANGELOG.yml ]
          then
            wget https://raw.githubusercontent.com/product-os/versionist/master/scripts/generate-changelog.sh
            echo "c1d25c8d5dc40e08a13c43ac93582661  generate-changelog.sh" | md5sum -c -
            chmod +x generate-changelog.sh

            wget https://github.com/mikefarah/yq/releases/download/3.0.1/yq_linux_amd64 -O yq
            echo "a1097c74b81a2ef255583d9718bf4be6  yq" | md5sum -c -
            chmod +x yq

            PATH="${PWD}:${PATH}" GH_TOKEN=${{ secrets.FLOWZONE_TOKEN }} ./generate-changelog.sh .
            rm yq generate-changelog.sh
          fi

      # install and run versionist via balena-versionist
      # create changelog yaml if it does not exist (TODO: versionist should handle this automatically)
      # exit if versionist didn't change anything
      - name: Run versionist
        if: needs.project_types.outputs.repo_type != '' && github.event_name == 'pull_request'
        id: versionist
        run: |
          old_version="$(yq e '.[0].version' -r .versionbot/CHANGELOG.yml)"

          npm install -g balena-versionist versionist
          balena-versionist
          git status --porcelain

          new_version="$(yq e '.[0].version' -r .versionbot/CHANGELOG.yml)"

          test -n "${new_version}" || { echo "Failed to get version from changelog!" ; exit 1 ; }

          test "${new_version}" != "${old_version}" || { echo "Version did not change, did you include a Change-type?" ; exit 1 ; }

          echo "::set-output name=version::${new_version}"
          echo "::set-output name=new_tag::v${new_version}"

      # create a versioned commit
      - name: Create versioned commit
        if: steps.versionist.outputs.new_tag != ''
        env:
          GIT_AUTHOR_NAME: ${{ steps.import-gpg.outputs.name }}
          GIT_AUTHOR_EMAIL: ${{ steps.import-gpg.outputs.email }}
          GIT_COMMITTER_NAME: ${{ steps.import-gpg.outputs.name }}
          GIT_COMMITTER_EMAIL: ${{ steps.import-gpg.outputs.email }}
          TAG: ${{ steps.versionist.outputs.new_tag }}
        run: |
          git add --all
          git commit -m "${TAG}"
          git tag -a "${TAG}" -m "${TAG}" -f
          git show -1
          git log -n 2

      # push the versioned commit only if the PR is merged
      - name: Push versioned commit
        if: github.event.pull_request.merged == true && steps.versionist.outputs.new_tag != ''
        run: |
          git push origin HEAD:${{ github.base_ref }} --follow-tags

      # https://github.com/actions/upload-artifact#maintaining-file-permissions-and-case-sensitive-files
      - name: Compress source
        run: tar -cvf /tmp/source.tar .

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}
          path: /tmp/source.tar
          retention-days: 1

  ###################################################
  ## npm
  ###################################################

  npm_test:
    name: Test npm
    runs-on: ubuntu-latest
    needs: [event_types, project_types, versioned_source]
    if: |
      needs.event_types.outputs.do_draft == 'true' &&
      needs.project_types.outputs.npm == 'true'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    strategy:
      fail-fast: false
      matrix:
        node_version: ${{ fromJSON(needs.project_types.outputs.node_versions) }}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "${{ matrix.node_version }}"

      - name: Install dependencies
        run: |
          if [ -e package-lock.json ]; then
            npm ci
          else
            npm i
          fi

      - name: Run build
        run: npm run build --if-present

      - name: Run tests
        run: npm test

  npm_publish:
    name: Publish npm
    runs-on: ubuntu-latest
    needs: [project_types, versioned_source, npm_test, custom_test]
    if: |
      !failure() && !cancelled() &&
      needs.npm_test.result == 'success' &&
      needs.event_types.outputs.do_draft == 'true' &&
      needs.project_types.outputs.npm_private != 'true'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - name: Generate tags
        id: meta
        run: |
          package="$(jq -r '.name' package.json)"
          version="$(jq -r '.version' package.json)"
          branch_tag="$(echo '${{ github.event.pull_request.head.ref }}' | sed 's/[^[:alnum:]]/-/g')"
          sha_tag="${branch_tag}-${{ github.event.pull_request.head.sha }}"
          version_tag="${version}-${branch_tag}-${{ github.event.pull_request.head.sha }}"

          echo "::set-output name=package::${package}"
          echo "::set-output name=version::${version}"
          echo "::set-output name=branch_tag::${branch_tag}"
          echo "::set-output name=sha_tag::${sha_tag}"
          echo "::set-output name=version_tag::${version_tag}"

      - name: Login to registry
        run: |
          echo '//${{ env.NPM_REGISTRY }}/:_authToken=${{ secrets.NPM_TOKEN }}' > ~/.npmrc
          npm whoami

      - name: Publish draft release
        run: |
          npm --loglevel=verbose --logs-max=0 --no-git-tag-version version ${{ steps.meta.outputs.version_tag }}
          npm --loglevel=verbose --logs-max=0 publish --tag=${{ steps.meta.outputs.sha_tag }}
          npm --loglevel=verbose --logs-max=0 dist-tag add ${{ steps.meta.outputs.package }}@${{ steps.meta.outputs.version_tag }} ${{ steps.meta.outputs.branch_tag }}

  npm_finalize:
    name: Finalize npm
    runs-on: ubuntu-latest
    needs: [event_types, project_types, versioned_source]
    if: |
      needs.event_types.outputs.do_final == 'true' &&
      needs.project_types.outputs.npm == 'true' &&
      needs.project_types.outputs.npm_private != 'true'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - name: Login to registry
        run: |
          echo '//${{ env.NPM_REGISTRY }}/:_authToken=${{ secrets.NPM_TOKEN }}' > ~/.npmrc
          npm whoami

      - name: Publish final release
        run: |
          npm --loglevel=verbose --logs-max=0 publish --tag "latest"

  ###################################################
  ## docker
  ###################################################

  docker_test:
    name: Test docker
    runs-on: ubuntu-latest
    needs: [event_types, project_types, versioned_source]
    if: |
      needs.event_types.outputs.do_draft == 'true' &&
      needs.project_types.outputs.docker_compose == 'true'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    env:
      COMPOSE_VARS: ${{ secrets.COMPOSE_VARS }}

    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJSON(needs.project_types.outputs.docker_platforms) }}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v2

      - name: Setup buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: network=host
          install: true

      - name: Set ARCHVARIANT
        run: |
          echo "ARCHVARIANT=$(echo "${{ matrix.platform }}" | sed -e 's|linux/||' -e 's|/||')" >> $GITHUB_ENV

      - name: Image metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          # even though this build is not published externally, the provided image tags
          # can be used in docker-compose.test.yml to avoid rebuilds
          images: |
            ${{ needs.project_types.outputs.docker_images }}
            ${{ github.repository }}
            sut
          tags: |
            type=raw,value=${{ needs.versioned_source.outputs.version }}
            type=raw,value=${{ env.ARCHVARIANT }}
            type=raw,value=edge
          flavor: |
            latest=true

      # https://github.com/docker/bake-action
      - name: Docker bake and load
        if: needs.project_types.outputs.docker_bake == 'true'
        uses: docker/bake-action@v2
        with:
          workdir: ${{ inputs.working_directory }}
          files: |
            ./docker-bake.hcl
            ${{ steps.meta.outputs.bake-file }}
          targets: build
          set: |
            *.platform=${{ matrix.platform }}
            *.cache-to=type=gha,scope=test-${{ env.ARCHVARIANT }},mode=max
            *.cache-from=type=gha,scope=test-${{ env.ARCHVARIANT }}
          load: true
          push: false

      # https://github.com/docker/build-push-action
      - name: Docker build and load
        if: needs.project_types.outputs.docker_bake != 'true'
        uses: docker/build-push-action@v3
        with:
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-to: type=gha,scope=test-${{ env.ARCHVARIANT }},mode=max
          cache-from: type=gha,scope=test-${{ env.ARCHVARIANT }}
          context: ${{ inputs.working_directory }}
          tags: |
            ${{ steps.meta.outputs.tags }}
          load: true
          push: false

      - name: Save image to file
        run: |
          docker save ${{ github.repository }}:${{ env.ARCHVARIANT }} > /tmp/docker.tar

      - name: Run docker compose tests
        run: |
          if [[ ! -z "${COMPOSE_VARS}" ]]; then
            echo ${COMPOSE_VARS} | base64 --decode > .env
          fi
          docker compose -f docker-compose.yml -f docker-compose.test.yml up --exit-code-from sut

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: docker-${{ env.ARCHVARIANT }}
          path: /tmp/docker.tar
          retention-days: 1

  docker_publish:
    name: Publish docker
    runs-on: ubuntu-latest
    needs: [project_types, versioned_source, npm_test, docker_test, custom_test]
    if: |
      !failure() && !cancelled() &&
      needs.docker_test.result == 'success' &&
      needs.event_types.outputs.do_draft == 'true' &&
      needs.project_types.outputs.docker_images != ''

    defaults:
      run:
        working-directory: .
        shell: bash --noprofile --norc -eo pipefail -x {0}

    env:
      LOCAL_IMAGE: localhost:5000/${{ github.repository }}

    services:
      registry:
        image: registry:2.8.1
        ports:
          - 5000:5000

    steps:
      - name: Login to GitHub Container Registry
        continue-on-error: true
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ env.GHCR_TOKEN }}

      - name: Login to Docker Hub
        continue-on-error: true
        uses: docker/login-action@v2
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USER || secrets.DOCKER_REGISTRY_USER }}
          password: ${{ secrets.DOCKERHUB_TOKEN || secrets.DOCKER_REGISTRY_PASS }}

      - name: Download all artifacts
        uses: actions/download-artifact@v3
        with:
          path: /tmp

      - name: Load images
        run: |
          for image in /tmp/docker-*/*.tar
          do
            ARCHVARIANT="$(dirname "${image}" | awk -F- '{print $NF}')"
            docker load -i "${image}" | tee /dev/stderr | awk '{print $NF}' |
              xargs -i docker tag {} "${{ env.LOCAL_IMAGE }}:${ARCHVARIANT}"
            docker push "${{ env.LOCAL_IMAGE }}:${ARCHVARIANT}"
          done

      # see https://github.com/estesp/manifest-tool to understand template
      - name: Create multi-arch manifest
        id: manifest
        run: |
          docker run --rm --network=host mplatform/manifest-tool:alpine-v2.0.5 push from-args \
            --platforms ${{ join(fromJSON(needs.project_types.outputs.docker_platforms)) }} \
            --template ${{ env.LOCAL_IMAGE }}:ARCHVARIANT \
            --target ${{ env.LOCAL_IMAGE }}:latest

      - name: Generate draft labels and tags
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ needs.project_types.outputs.docker_images }}
          tags: |
            type=raw,value=${{ github.event.pull_request.head.sha }}
            type=raw,value=${{ github.event.pull_request.head.ref }}
            type=ref,event=pr
          flavor: |
            latest=false

      - name: Publish draft tags
        uses: akhilerm/tag-push-action@v2.0.0
        with:
          src: ${{ env.LOCAL_IMAGE }}:latest
          dst: |
            ${{ steps.meta.outputs.tags }}

  docker_finalize:
    name: Finalize docker
    runs-on: ubuntu-latest
    needs: [event_types, project_types, versioned_source]
    if: |
      needs.event_types.outputs.do_final == 'true' &&
      needs.project_types.outputs.docker_images != '' &&
      needs.project_types.outputs.docker_compose == 'true'

    defaults:
      run:
        working-directory: .
        shell: bash --noprofile --norc -eo pipefail -x {0}

    env:
      LOCAL_IMAGE: localhost:5000/${{ github.repository }}

    services:
      registry:
        image: registry:2.8.1
        ports:
          - 5000:5000

    steps:
      - name: Login to GitHub Container Registry
        continue-on-error: true
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ env.GHCR_TOKEN }}

      - name: Login to Docker Hub
        continue-on-error: true
        uses: docker/login-action@v2
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USER || secrets.DOCKER_REGISTRY_USER }}
          password: ${{ secrets.DOCKERHUB_TOKEN || secrets.DOCKER_REGISTRY_PASS }}

      # merged pull requests
      - name: Generate versioned labels and tags
        id: versioned_meta
        if: github.event.pull_request.merged == true && needs.versioned_source.outputs.version != ''
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ needs.project_types.outputs.docker_images }}
          tags: |
            type=raw,value=${{ needs.versioned_source.outputs.version }}
          flavor: |
            latest=true

      # merged pull requests with versioning disabled
      - name: Generate edge labels and tags
        id: edge_meta
        if: github.event.pull_request.merged == true && needs.versioned_source.outputs.version == ''
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ needs.project_types.outputs.docker_images }}
          tags: |
            type=raw,value=edge
          flavor: |
            latest=false

      # tag pushed to main branch
      - name: Generate tagged labels and tags
        id: tagged_meta
        if: github.event_name == 'push'
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ needs.project_types.outputs.docker_images }}
          tags: |
            type=ref,event=tag
            type=semver,pattern={{version}}
          flavor: |
            latest=auto

      # try to pull existing draft releases that we can republish as final
      - name: Pull draft images
        env:
          IMAGES: ${{ needs.project_types.outputs.docker_images }}
        run: |
          for image in ${IMAGES}
          do
            docker pull ${image}:${{ github.event.pull_request.head.sha }} || continue
            docker tag ${image}:${{ github.event.pull_request.head.sha }} ${{ env.LOCAL_IMAGE }}:latest
            docker push ${{ env.LOCAL_IMAGE }}:latest
            success=1
            break
          done
          test -n "${success}"

      # only one of the destination lines should have values based on the meta restrictions above
      - name: Publish final tags
        uses: akhilerm/tag-push-action@v2.0.0
        with:
          src: ${{ env.LOCAL_IMAGE }}:latest
          dst: |
            ${{ steps.versioned_meta.outputs.tags }}
            ${{ steps.edge_meta.outputs.tags }}
            ${{ steps.tagged_meta.outputs.tags }}

  ###################################################
  ## balena
  ###################################################

  balena_publish:
    name: Publish balena
    runs-on: ubuntu-latest
    needs:
      [
        event_types,
        project_types,
        versioned_source,
        npm_test,
        docker_test,
        custom_test,
      ]
    if: |
      !failure() && !cancelled() &&
      needs.event_types.outputs.do_draft == 'true' &&
      needs.project_types.outputs.balena == 'true'

    strategy:
      fail-fast: false
      matrix:
        slug: ${{ fromJSON(needs.project_types.outputs.balena_slugs) }}

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - uses: balena-io/deploy-to-balena-action@v0.13.0
        with:
          balena_token: ${{ secrets.BALENA_API_KEY || secrets.BALENA_API_KEY_PUSH }}
          fleet: ${{ matrix.slug }}
          versionbot: false # disable the included versionbot branch checkout
          source: ${{ inputs.working_directory }}

  balena_finalize:
    name: Finalize balena
    runs-on: ubuntu-latest
    needs: [event_types, project_types, versioned_source]
    if: |
      needs.event_types.outputs.do_final == 'true' &&
      needs.project_types.outputs.balena == 'true'

    strategy:
      fail-fast: false
      matrix:
        slug: ${{ fromJSON(needs.project_types.outputs.balena_slugs) }}

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - uses: balena-io/deploy-to-balena-action@v0.13.0
        with:
          balena_token: ${{ secrets.BALENA_API_KEY || secrets.BALENA_API_KEY_PUSH }}
          fleet: ${{ matrix.slug }}
          versionbot: false # disable the included versionbot branch checkout
          source: ${{ inputs.working_directory }}

  ###################################################
  ## custom
  ###################################################

  custom_test:
    name: Test custom
    runs-on: ubuntu-latest
    needs: [event_types, project_types, versioned_source]
    if: |
      needs.event_types.outputs.do_draft == 'true' &&
      needs.project_types.outputs.custom_test == 'true'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - name: Call custom action
        uses: ./.github/flowzone/finalize
        with:
          flowzone_token: ${{ secrets.FLOWZONE_TOKEN }}
          shell: bash --noprofile --norc -eo pipefail -x {0}

  custom_publish:
    name: Publish custom
    runs-on: ubuntu-latest
    needs:
      [
        event_types,
        project_types,
        versioned_source,
        npm_test,
        docker_test,
        custom_test,
      ]
    if: |
      !failure() && !cancelled() &&
      needs.event_types.outputs.do_draft == 'true' &&
      needs.project_types.outputs.custom_publish == 'true'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - name: Call custom action
        uses: ./.github/flowzone/finalize
        with:
          flowzone_token: ${{ secrets.FLOWZONE_TOKEN }}
          shell: bash --noprofile --norc -eo pipefail -x {0}

  custom_finalize:
    name: Finalize custom
    runs-on: ubuntu-latest
    needs: [event_types, project_types, versioned_source]
    if: |
      needs.event_types.outputs.do_final == 'true' &&
      needs.project_types.outputs.custom_finalize == 'true'

    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      - name: Download source artifact
        uses: actions/download-artifact@v3
        with:
          name: source-${{ github.event.pull_request.head.sha }}

      - name: Extract source artifact
        working-directory: .
        run: tar -xvf source.tar

      - name: Call custom action
        uses: ./.github/flowzone/finalize
        with:
          flowzone_token: ${{ secrets.FLOWZONE_TOKEN }}
          shell: bash --noprofile --norc -eo pipefail -x {0}

  ###################################################
  ## protect branch
  ###################################################

  protect_branch:
    name: Protect branch
    runs-on: ubuntu-latest
    needs:
      [
        event_types,
        project_types,
        versioned_source,
        docker_test,
        npm_test,
        custom_test,
        docker_publish,
        npm_publish,
        custom_publish,
        balena_publish,
      ]
    # avoid being skipped when dependencies are skipped
    # this job must always run so branch protection rules can depend on it
    if: |
      always() &&
      needs.event_types.outputs.do_draft == 'true' &&
      inputs.protect_branch == true

    outputs:
      result: ${{ steps.apply_branch_protection_rules.outputs.result }}

    defaults:
      run:
        working-directory: .
        shell: bash --noprofile --norc -eo pipefail -x {0}

    steps:
      # loop over all needed jobs and fail this job if any of them failed
      - name: Check needed jobs
        run: |
          for result in $(echo '${{ toJSON(needs.*.result) }}' | jq -cr '.[]')
          do
            test "${result}" = "success" && continue
            test "${result}" = "skipped" && continue
            echo "Needed job returned result: ${result}"
            exit 1
          done

      - name: Apply branch protection rules
        id: apply_branch_protection_rules
        run: |
          url='${{ github.api_url }}/repos/${{ github.repository }}/branches/${{ github.event.repository.default_branch }}/protection'

          result="$(curl --silent -X PUT "${url}" \
            -H 'Accept: application/vnd.github+json' \
            -H 'Authorization: Bearer ${{ secrets.FLOWZONE_TOKEN }}' \
            -d '{
            "required_status_checks": {
              "strict": true,
              "contexts": [
                "Flowzone / Event types",
                "Flowzone / Project types",
                "Flowzone / Versioned source",
                "Flowzone / Protect branch"
              ]
            },
            "enforce_admins": false,
            "required_pull_request_reviews": {
              "dismissal_restrictions": {
                "users": [],
                "teams": []
              },
              "dismiss_stale_reviews": false,
              "require_code_owner_reviews": false,
              "required_approving_review_count": ${{ inputs.required_approving_review_count }},
              "bypass_pull_request_allowances": {
                "users": [],
                "teams": []
              }
            },
            "restrictions": null,
            "required_linear_history": false,
            "allow_force_pushes": false,
            "allow_deletions": false,
            "block_creations": false,
            "required_conversation_resolution": false
          }')"

          echo ::set-output name=result::"${result}"
